import { parseContent } from './parsers';
import defaultSchema from './schema';
const isEmptyInputValue = (value) => {
    // we don't check for string here so it also works with arrays
    return value === null || value.length === 0;
};
const hasValidLength = (value) => {
    // non-strict comparison is intentional, to check for both `null` and `undefined` values
    return value !== null && typeof value.length === 'number';
};
const isDocEmpty = (doc) => {
    if (!doc) {
        return true;
    }
    const { childCount, firstChild } = doc;
    return Boolean(childCount === 1 && firstChild?.isTextblock && firstChild.content.size === 0);
};
// @dynamic
export class Validators {
    static required(userSchema) {
        return (control) => {
            const schema = userSchema || defaultSchema;
            const doc = parseContent(control.value, schema);
            const isEmpty = isDocEmpty(doc);
            if (!isEmpty) {
                return null;
            }
            return {
                required: true,
            };
        };
    }
    static maxLength(maxLength, userSchema) {
        return (control) => {
            const schema = userSchema || defaultSchema;
            const doc = parseContent(control.value, schema);
            const value = doc.textContent;
            if (hasValidLength(value) && value.length > maxLength) {
                return {
                    maxlength: {
                        requiredLength: maxLength,
                        actualLength: value.length,
                    },
                };
            }
            return null;
        };
    }
    static minLength(minLength, userSchema) {
        return (control) => {
            const schema = userSchema || defaultSchema;
            const doc = parseContent(control.value, schema);
            const value = doc.textContent;
            if (isEmptyInputValue(value) || !hasValidLength(value)) {
                // don't validate empty values to allow optional controls
                // don't validate values without `length` property
                return null;
            }
            if (value.length < minLength) {
                return {
                    minlength: {
                        requiredLength: minLength, actualLength: value.length,
                    },
                };
            }
            return null;
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1lZGl0b3Ivc3JjL2xpYi92YWxpZGF0b3JzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDekMsT0FBTyxhQUFhLE1BQU0sVUFBVSxDQUFDO0FBSXJDLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxLQUFVLEVBQVcsRUFBRTtJQUNoRCw4REFBOEQ7SUFDOUQsT0FBTyxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBQzlDLENBQUMsQ0FBQztBQUVGLE1BQU0sY0FBYyxHQUFHLENBQUMsS0FBVSxFQUFXLEVBQUU7SUFDN0Msd0ZBQXdGO0lBQ3hGLE9BQU8sS0FBSyxLQUFLLElBQUksSUFBSSxPQUFPLEtBQUssQ0FBQyxNQUFNLEtBQUssUUFBUSxDQUFDO0FBQzVELENBQUMsQ0FBQztBQUVGLE1BQU0sVUFBVSxHQUFHLENBQUMsR0FBMkIsRUFBVyxFQUFFO0lBQzFELElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDUixPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsTUFBTSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsR0FBRyxHQUFHLENBQUM7SUFDdkMsT0FBTyxPQUFPLENBQUMsVUFBVSxLQUFLLENBQUMsSUFBSSxVQUFVLEVBQUUsV0FBVyxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQy9GLENBQUMsQ0FBQztBQUVGLFdBQVc7QUFDWCxNQUFNLE9BQU8sVUFBVTtJQUNyQixNQUFNLENBQUMsUUFBUSxDQUFDLFVBQW1CO1FBQ2pDLE9BQU8sQ0FBQyxPQUF3QixFQUEyQixFQUFFO1lBQzNELE1BQU0sTUFBTSxHQUFHLFVBQVUsSUFBSSxhQUFhLENBQUM7WUFDM0MsTUFBTSxHQUFHLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFFaEQsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRWhDLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ1osT0FBTyxJQUFJLENBQUM7YUFDYjtZQUVELE9BQU87Z0JBQ0wsUUFBUSxFQUFFLElBQUk7YUFDZixDQUFDO1FBQ0osQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBaUIsRUFBRSxVQUFtQjtRQUNyRCxPQUFPLENBQUMsT0FBd0IsRUFBMkIsRUFBRTtZQUMzRCxNQUFNLE1BQU0sR0FBRyxVQUFVLElBQUksYUFBYSxDQUFDO1lBQzNDLE1BQU0sR0FBRyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRWhELE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUM7WUFFOUIsSUFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxTQUFTLEVBQUU7Z0JBQ3JELE9BQU87b0JBQ0wsU0FBUyxFQUFFO3dCQUNULGNBQWMsRUFBRSxTQUFTO3dCQUN6QixZQUFZLEVBQUUsS0FBSyxDQUFDLE1BQU07cUJBQzNCO2lCQUNGLENBQUM7YUFDSDtZQUVELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBaUIsRUFBRSxVQUFtQjtRQUNyRCxPQUFPLENBQUMsT0FBd0IsRUFBMkIsRUFBRTtZQUMzRCxNQUFNLE1BQU0sR0FBRyxVQUFVLElBQUksYUFBYSxDQUFDO1lBQzNDLE1BQU0sR0FBRyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRWhELE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUM7WUFFOUIsSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDdEQseURBQXlEO2dCQUN6RCxrREFBa0Q7Z0JBQ2xELE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFFRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsU0FBUyxFQUFFO2dCQUM1QixPQUFPO29CQUNMLFNBQVMsRUFBRTt3QkFDVCxjQUFjLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsTUFBTTtxQkFDdEQ7aUJBQ0YsQ0FBQzthQUNIO1lBRUQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIFZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU2NoZW1hLCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcblxuaW1wb3J0IHsgcGFyc2VDb250ZW50IH0gZnJvbSAnLi9wYXJzZXJzJztcbmltcG9ydCBkZWZhdWx0U2NoZW1hIGZyb20gJy4vc2NoZW1hJztcblxudHlwZSBWYWxpZGF0aW9uRXJyb3JzID0gUmVjb3JkPHN0cmluZywgYW55PjtcblxuY29uc3QgaXNFbXB0eUlucHV0VmFsdWUgPSAodmFsdWU6IGFueSk6IGJvb2xlYW4gPT4ge1xuICAvLyB3ZSBkb24ndCBjaGVjayBmb3Igc3RyaW5nIGhlcmUgc28gaXQgYWxzbyB3b3JrcyB3aXRoIGFycmF5c1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xufTtcblxuY29uc3QgaGFzVmFsaWRMZW5ndGggPSAodmFsdWU6IGFueSk6IGJvb2xlYW4gPT4ge1xuICAvLyBub24tc3RyaWN0IGNvbXBhcmlzb24gaXMgaW50ZW50aW9uYWwsIHRvIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzXG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJztcbn07XG5cbmNvbnN0IGlzRG9jRW1wdHkgPSAoZG9jOiBQcm9zZU1pcnJvck5vZGUgfCBudWxsKTogYm9vbGVhbiA9PiB7XG4gIGlmICghZG9jKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCB7IGNoaWxkQ291bnQsIGZpcnN0Q2hpbGQgfSA9IGRvYztcbiAgcmV0dXJuIEJvb2xlYW4oY2hpbGRDb3VudCA9PT0gMSAmJiBmaXJzdENoaWxkPy5pc1RleHRibG9jayAmJiBmaXJzdENoaWxkLmNvbnRlbnQuc2l6ZSA9PT0gMCk7XG59O1xuXG4vLyBAZHluYW1pY1xuZXhwb3J0IGNsYXNzIFZhbGlkYXRvcnMge1xuICBzdGF0aWMgcmVxdWlyZWQodXNlclNjaGVtYT86IFNjaGVtYSk6IFZhbGlkYXRvckZuIHtcbiAgICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IHVzZXJTY2hlbWEgfHwgZGVmYXVsdFNjaGVtYTtcbiAgICAgIGNvbnN0IGRvYyA9IHBhcnNlQ29udGVudChjb250cm9sLnZhbHVlLCBzY2hlbWEpO1xuXG4gICAgICBjb25zdCBpc0VtcHR5ID0gaXNEb2NFbXB0eShkb2MpO1xuXG4gICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIG1heExlbmd0aChtYXhMZW5ndGg6IG51bWJlciwgdXNlclNjaGVtYT86IFNjaGVtYSk6IFZhbGlkYXRvckZuIHtcbiAgICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IHVzZXJTY2hlbWEgfHwgZGVmYXVsdFNjaGVtYTtcbiAgICAgIGNvbnN0IGRvYyA9IHBhcnNlQ29udGVudChjb250cm9sLnZhbHVlLCBzY2hlbWEpO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IGRvYy50ZXh0Q29udGVudDtcblxuICAgICAgaWYgKGhhc1ZhbGlkTGVuZ3RoKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXhsZW5ndGg6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkTGVuZ3RoOiBtYXhMZW5ndGgsXG4gICAgICAgICAgICBhY3R1YWxMZW5ndGg6IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIG1pbkxlbmd0aChtaW5MZW5ndGg6IG51bWJlciwgdXNlclNjaGVtYT86IFNjaGVtYSk6IFZhbGlkYXRvckZuIHtcbiAgICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IHVzZXJTY2hlbWEgfHwgZGVmYXVsdFNjaGVtYTtcbiAgICAgIGNvbnN0IGRvYyA9IHBhcnNlQ29udGVudChjb250cm9sLnZhbHVlLCBzY2hlbWEpO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IGRvYy50ZXh0Q29udGVudDtcblxuICAgICAgaWYgKGlzRW1wdHlJbnB1dFZhbHVlKHZhbHVlKSB8fCAhaGFzVmFsaWRMZW5ndGgodmFsdWUpKSB7XG4gICAgICAgIC8vIGRvbid0IHZhbGlkYXRlIGVtcHR5IHZhbHVlcyB0byBhbGxvdyBvcHRpb25hbCBjb250cm9sc1xuICAgICAgICAvLyBkb24ndCB2YWxpZGF0ZSB2YWx1ZXMgd2l0aG91dCBgbGVuZ3RoYCBwcm9wZXJ0eVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1pbmxlbmd0aDoge1xuICAgICAgICAgICAgcmVxdWlyZWRMZW5ndGg6IG1pbkxlbmd0aCwgYWN0dWFsTGVuZ3RoOiB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgfVxufVxuIl19